# 多线程与高并发

## 1.并发的优势和挑战

### 1.1什么是并发

串行：顺序做不同的事情

并发：交替做不同的事情，关注的是资源的充分利用，不让cup停下来，为了更快的完成一件事情，一个任务交给多个执行者同时做。

并行：同时做不同的事情

### 1.2上下文问题

即便是单核处理器也支持多线程，cup通过给每个线程分配时间片来实现多线程。当前任务执行一个时间片之后会切换到下一个任务，但是在切换之前会保存当前的状态，然后下次切换回来的时候从这个保存的状态开始执行，那么一次保存状态到重新加载的过程就是一次上下文切换。

这个过程是有cup开销的，所以有时候多线程执行起来还不如单线程块。

### 1.3如何减少上下文切换

#### 1.无锁并发编程

执行任务的时候，多线程竞争锁会引起上下文切换，我们可以用别的办法来避免使用锁，比如将数据取模分段，不同的线程处理不同段的数据。

#### 2.CAS算法

一种更新数据的算法，不需要使用到锁。

#### 3.使用少线程

创建适量的线程，避免大量线程处于等待状态。

#### 4.使用妥协

使用单线程来维持多个任务的切换。

```ini
总结:使用适量线程，尽量少用锁，执行内容分配前置，上下文切换就会变少。
```

### 1.4 死锁问题

多线程并发节约了cup资源，那么就会访问共享的和可能已经变化的资源，这样是有线程安全问题的。所以我们要保证共享的和可变的资源不被错误的执行，就会使用到锁。

```java
public class ThreadTest{
  Object moniterA = new Object();
  Object moniterB = new Object();
  /**
  * 创建第一个锁
  */
  Thread t1 = new Thread(() -> {
    synchronized(moniterA){
      Thread.sleep(2000);
      synchronized(moniterB){
        println("A");
      }
    }
  });
  Thread t2 = new Thread(() -> {
    synchronized(moniterB){
      Thread.sleep(2000);
      synchronized(moniterA){
        println("B");
      }
    }
  });
  t1.start();
  t2.start();
}
```

**为什么会陷入死锁**

### 1.5如何避免死锁

一个线程拿到锁之后因为异常没有释放掉锁，或者释放锁的时候跑出异常没有释放。这样就会造成死锁为题。

- 不要一个线程同时占用多个锁。
- 不要一个线程在锁内同时占用多个资源，也就是每个锁只用一个资源。
- 使用锁的时候，使用lock.tryLock(timeout)来代替内部锁。
- 对于数据库锁，加锁和解锁必须在一个数据库连接中。不然会解锁失败

```ini
总结:一个线程只能使用一个定时锁去锁住一个资源。
```

### 1.6资源限制

在并发编程时，我们往往受限于计算机硬件和软件资源。

- 硬件资源：宽带、硬盘读写速度、cup处理速度
- 软件资源：数据库连接数和socket连接数

```ini
并发是为了使代码执行更快，原则是把部分串行改成并发执行，但是如果受限于硬件资源，仍然在串行，那么返回会变得更慢。
```

解决方法：

- 硬件资源：考虑分布式集群来并发执行
- 软件资源：考虑使用资源池复用资源

```ini
总结:解决资源受限，就是分布式集群的搭建和资源池建立和复用。
```



